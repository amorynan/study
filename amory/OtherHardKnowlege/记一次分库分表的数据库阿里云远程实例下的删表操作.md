###非常惊心动魄的一天，接触了一次线上数据库磁盘满了，然后各种问题的出现，删表的经历，为后面不吃屎打下一个预防针


1. 场景一：老板早上给我说数据库磁盘快要满了，90% ，让我删除表中的数据，并且最好有条件的删除
 ok，我看连接了vpn后登上了数据库的实例，还是一个数据库实例进行了分库分表的操作，关于如何优雅的分库分表我后面再说，先描述问题
 
 分了10个数据库，然后每个数据库都有两张表，一张表的没有太大，虽然比较长，但是数据量都不是很大，另外一张表，我嘞个去，基本上都是10+G, 好，这不撑满磁盘才怪，然后二话不说撸起袖子就开始直接新建数据库语句进行delete，因为看见有time_map类型的字段，所以比较担忧的我采用了条件语句where，以一个时间节点作为删除节点，大概类似 delete from table_name where time <= 'yyyy-mm-dd hh:mm:ss' 然后就发生了这个事务上面显示的执行图标一直转，旋转跳跃我不停歇，一气之下，我索性在每个数据库中都写了这个事务，然后果然祸不单行，突然产生了lock的结果，然后我就慌了，数据库锁了？还是表锁了？为什么锁，做了什么导致锁了，我的天，我在哪？我要干啥哈哈哈
一脸懵逼的我按照常人的思维，复制了查询下面的报错语句问度娘
####Lock wait timeout exceeded; try restarting transaction
这里首先得搞清楚是表被锁了，而不是库被锁了，这两个不是一个等级的概念，根据运维的小伙伴传授的经验，在磁盘满了的情况下，数据库的实例会被锁住，其实仔细想想也是，sql server instance是指的是os 给mysql server 分配的某个进程，由它来进行数据从磁盘和内存之间的流动的，你都让磁盘满了，人家不锁住你，还让你撑爆整个磁盘吗？这个时候一般就是所有数据库相关的进程都没有作用了，然后我在这次事件中也遇到了，还真的就是我不管操作哪个库，用什么语句，都会显示一个结果，那就是read only了，在对应的数据库服务器上就是所谓的宕机了，而且还不一定是实时的，这个时候解决的办法就是一个想尽办法释放部分空间，还是根据运维小伙伴提出的建议，1. 删除binlog，因为其实binlog 的数据量也是客观的，描述了数据库更新的事务行为，这个会在一定时间内mysql进行一次磁盘的同步，将binlog也写入磁盘的，注意要和innodb undo / redo log 进行区分,描述了事务操作的内容，用于主从的复制，是mysql级别的，而redo undo 是innodb 执行引擎级别的，用来记录数据页的修改情况
2. 如果没有太多的作用，或者也删不了的话，就需要为mysql instance 进行扩容了，先让它运行起来，然后见缝插针的删除，幸亏我开始的delete语句还是起了一些作业，应该是redo 这个好帮手，在某一个时刻删除了一大部分的数据，让数据库running了，然后我就立马用了truncate table 进行清表，当然这之前肯定会问相关业务方是否是需要的数据，因为我的项目是爬虫项目，爬取的很大一部分内容其实没有很多的用处，所以就没有关系
3. 当然事后爱总结的我，立马觉得可以写一些BP 来记录下，首先监控必不可少，特别是对于大企业级别的，这样可以根据当天的日增量趋势进行排查和及时清除，初次之外，有了这个教训，最根本的还是要先从业务代码出发，是不是完全可以先避免这些大的数据，并且没有的数据先进行正则过滤掉，不写入呢？最后再从冷热数据的角度出发，进行一个垂直分表的操作，通过这个过程，还有一点就是关于sql语句的bp那就是对where 语句后面经常操作的字段可以加上索引。那这个又是为啥呢？ 索引是干啥的？好我们接下来深入一下数据库进行剖析


